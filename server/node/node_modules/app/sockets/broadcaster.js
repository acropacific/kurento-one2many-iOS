var kurento        = require('app/kurento-client');
var Promise        = require('bluebird');
var uuid           = require('uuid-v4');
var isAuth         = require('app/auth/is-auth');
var bcmgr          = require('app/broadcasts/manager');
var makeSaveDir    = require('app/broadcasts/makeDir');
var toMp4          = require('app/broadcasts/toMp4');
var config         = require('app/config');
var getRoomName    = require('app/broadcasts/get-room-name');
var recordFormat   = config.video.format.record;
var playbackFormat = config.video.format.playback;

module.exports = function(io, client) {

  var nsp = io.of('/broadcaster');
  nsp.on('connection', function(socket) {

    socket.on('broadcast-offer', function(msg, cb) {

      // if (!sessionToken) {

      var broadcast = {
        socket: socket,
        id: uuid(),
        sessionToken: sessionToken
      };

      isAuth(broadcast.sessionToken).then(function(auth) {
        // if (!auth) {
        return client.createAsync('MediaPipeline');
      }).then(function(pipeline) {
        Promise.promisifyAll(pipeline);
        broadcast.pipeline = pipeline;
        socket.once('disconnect', endBroadcast);
        socket.once('error', endBroadcast);
        return makeSaveDir(broadcast.id);
      }).then(function(savePath) {
        broadcast.file = savePath+'/'+broadcast.id+'.'+recordFormat;
        return broadcast.pipeline.createAsync('RecorderEndpoint', {
          mediaProfile: recordFormat.toUpperCase(),
          uri: 'file://'+broadcast.file
        });
      }).then(function(recorderEndpoint) {
        Promise.promisifyAll(recorderEndpoint);
        broadcast.recorderEndpoint = recorderEndpoint;
        return broadcast.pipeline.createAsync('WebRtcEndpoint');
      }).then(function(webRtcEndpoint) {
        Promise.promisifyAll(webRtcEndpoint);
        broadcast.webRtcEndpoint = webRtcEndpoint;
        webRtcEndpoint.on('OnIceCandidate', function(event) {
          var candidate = kurento.register.complexTypes.IceCandidate(event.candidate);
          socket.emit('broadcast-icecandidate', {
            candidate: candidate,
            broadcastId: broadcast.id
          });
        });
        return Promise.all([
          webRtcEndpoint.processOfferAsync(msg.offer),
          webRtcEndpoint.gatherCandidatesAsync()
        ]);
      }).spread(function(answer) {
        return Promise.all([
          answer,
          broadcast.webRtcEndpoint.connectAsync(broadcast.recorderEndpoint)
        ]);
      }).spread(function(answer) {
        bcmgr.addIdle(broadcast);
        cb(null, {
          broadcastId: broadcast.id,
          answer: answer
        });
      }).catch(function(err) {
        broadcast.pipeline.release();
        cb(err);
      });
    });

    socket.on('broadcast-begin', function(msg, cb) {
      var broadcast = bcmgr.getBroadcast(msg.broadcastId);
      return broadcast.recorderEndpoint.recordAsync().then(function() {
        bcmgr.makeBroadcastLive(broadcast.id);
      }).asCallback(cb);
    });

    socket.on('broadcast-icecandidate', function(msg) {
      var broadcast = bcmgr.getBroadcast(msg.broadcastId);
      var candidate = kurento.register.complexTypes.IceCandidate(msg.candidate);
      broadcast.webRtcEndpoint.addIceCandidate(candidate);
    });

    socket.on('broadcast-end', function(msg, cb) {
      var broadcast = bcmgr.getBroadcast(msg.broadcastId);
      endBroadcast(broadcast).asCallback(cb);
    });

    function endBroadcast(broadcast) {
      var wasLive = bcmgr.isLive(broadcast.id);
      bcmgr.removeBroadcast(broadcast.id);
      io.of('viewer').to(getRoomName(broadcast.id)).emit('broadcast-end');
      return broadcast.pipeline.releaseAsync().then(function() {
        if (!wasLive) { return; }
        if (recordFormat !== 'mp4' && playbackFormat === 'mp4') {
          return toMp4Async(broadcast.file).then(function() {
            fs.unlink(broadcast.file); // delete old file
          });
        }
      });
    }

  });

};
