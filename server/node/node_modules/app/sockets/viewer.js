var kurento        = require('app/kurento-client');
var Promise        = require('bluebird');
var config         = require('app/config');
var isAuth         = require('app/auth/isAuth');
var uuid           = require('uuid-v4');
var bcmgr          = require('app/broadcasts/manager');
var getRoomName    = require('app/broadcasts/get-room-name');

module.exports = function(io, client) {

  var nsp = io.of('/viewer');
  nsp.on('connection', function(socket) {

    socket.on('broadcast-view-offer', function(msg, cb) {

      var broadcast = bcmgr.getLiveBroadcast(msg.broadcastId);
      if (!broadcast) { return cb(`Broadcast id=${msg.broadcastId} not found.`); }

      var viewer = {
        id: uuid()
      };

      var room = getRoomName(broadcast.id);

      broadcast.pipeline.createAsync('WebRtcEndpoint').then(function(webRtcEndpoint) {
        Promise.promisifyAll(webRtcEndpoint);
        viewer.webRtcEndpoint = webRtcEndpoint;

        socket.join(room);

        function candidateListener(candidate) {
          var candidate = kurento.register.complexTypes.IceCandidate(candidate);
          webRtcEndpoint.addIceCandidate(candidate);
        }
        socket.on('viewerCandidate', candidateListener);

        // need to make sure this is called in situations it ought to be:
        // user stopped watching, user dc'd, broadcast ended
        function viewerEnd() {
          socket.leave(room);
          viewer.webRtcEndpoint.release();
          socket.removeListener('viewerCandidate', candidateListener);
        }
        socket.once('disconnect', viewerEnd);

        webRtcEndpoint.on('OnIceCandidate', function(event) {
          var candidate = kurento.register.complexTypes.IceCandidate(event.candidate);
          socket.emit('iceCandidate', candidate);
        });

        return Promise.all([
          webRtcEndpoint.processOfferAsync(msg.offer),
          webRtcEndpoint.gatherCandidatesAsync()
        ]);
      }).spread(function(answer) {
        return Promise.all([
          answer,
          broadcast.webRtcEndpoint.connectAsync(viewer.webRtcEndpoint)
        ]);
      }).spread(function(answer) {
        cb(null, {
          answer: answer,
          viewerId: viewer.id
        });
      })
    });

  });

};
