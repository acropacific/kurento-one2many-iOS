var kurento        = require('app/kurento-client');
var Promise        = require('bluebird');
var config         = require('app/config');
var isAuth         = require('app/auth/is-auth');
var uuid           = require('uuid-v4');
var bcmgr          = require('app/broadcasts/manager');
var getRoomName    = require('app/broadcasts/get-room-name');

module.exports = function(io, client) {

  var nsp = io.of('/viewer');
  nsp.on('connection', function(socket) {

    socket.on('offer', function(msg, cb) {

      var broadcast = bcmgr.getLiveBroadcast(msg.broadcastId);
      if (!broadcast) { return cb(`Broadcast id=${msg.broadcastId} not found.`); }

      var viewer = {
        id: uuid()
      };

      var room = getRoomName(broadcast.id);

      broadcast.pipeline.createAsync('WebRtcEndpoint').then(function(webRtcEndpoint) {
        Promise.promisifyAll(webRtcEndpoint);
        viewer.webRtcEndpoint = webRtcEndpoint;

        socket.join(room);
        var i = 0;
        function candidateListener(msg) {
          console.log('candidate fro browser', ++i);
          var candidate = kurento.register.complexTypes.IceCandidate(msg.candidate);
          webRtcEndpoint.addIceCandidate(candidate);
        }
        socket.on('icecandidate', candidateListener);

        // need to make sure this is called in situations it ought to be:
        // user stopped watching, user dc'd, broadcast ended
        function viewerEnd() {
          socket.leave(room);
          viewer.webRtcEndpoint.release();
          socket.removeListener('viewerCandidate', candidateListener);
        }
        socket.once('disconnect', viewerEnd);

        var j = 0;
        webRtcEndpoint.on('OnIceCandidate', function(event) {
          console.log('OnIceCandidate', ++j);
          var candidate = kurento.register.complexTypes.IceCandidate(event.candidate);
          socket.emit('icecandidate', candidate);
        });

        return Promise.all([
          webRtcEndpoint.processOfferAsync(msg.offerSdp),
          webRtcEndpoint.gatherCandidatesAsync()
        ]);
      }).spread(function(answerSdp) {
        return Promise.all([
          answerSdp,
          broadcast.webRtcEndpoint.connectAsync(viewer.webRtcEndpoint)
        ]);
      }).spread(function(answerSdp) {
        console.log('view accepted');
        cb(null, {
          answerSdp: answerSdp,
          viewerId: viewer.id
        });
      })
    });

  });

};
